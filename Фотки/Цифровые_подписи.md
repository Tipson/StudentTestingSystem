Цифровые подписи: подробный отчёт

Глава 1. История и развитие цифровых подписей

Понятие и мотивация использования. Цифровая подпись (также электронно-цифровая подпись, ЭЦП) – это криптографический механизм, позволяющий подтвердить подлинность и целостность электронного сообщения или документа, а также обеспечить невозможность отказа автора от факта подписания. Иначе говоря, цифровая подпись играет роль электронной аналогии собственноручной подписи, но обладает более мощными свойствами: проверяемостью подлинности через открытый ключ и стойкостью к подделке при соблюдении условий безопасности алгоритма. Мотивация использования цифровых подписей появилась с развитием электронных коммуникаций – потребовалось гарантировать, что сообщение действительно исходит от заявленного отправителя (аутентичность) и не было изменено по дороге (целостность), а также обеспечить неотрекаемость – чтобы автор не мог впоследствии отвергать свою подпись. Эти свойства цифровой подписи широко используются в протоколах безопасности (электронная почта, веб-протоколы, банковские системы), в инфраструктуре открытых ключей (сертификаты X.509) и в законодательстве об электронном документообороте.

Ранние концепции и появление первой цифровой подписи. Идея асимметричной криптографии, которая дала основу цифровым подписям, была впервые предложена Уитфилдом Диффи и Мартином Хеллманом в 1976 году. В своей знаменитой работе они описали концепцию систем с открытым ключом и упомянули возможность реализации электронной подписи с использованием пары ключей (открытого и закрытого). Однако конкретного практического алгоритма подписи в 1976 году они не предложили – требовалась функция одностороннего преобразования, которая была бы трудно обратима. В 1977 году произошло значимое событие: Рональд Ривест, Ади Шамир и Леонард Адлеман разработали первую практичную криптосистему с открытым ключом – алгоритм RSA. Криптосистема RSA стала первой, пригодной и для шифрования, и для создания цифровой подписи. История создания RSA примечательна: после нескольких неудачных попыток найти подходящую математическую идею Ривесту пришло озарение бессонной ночью, и итоговый алгоритм был назван по начальным буквам фамилий его создателей. RSA основан на сложности факторизации больших составных чисел (произведений двух больших простых), и уже в конце 1970-х было осознано, что помимо шифрования этот механизм позволяет реализовать подпись: владелец секретного ключа может возвести сообщение (точнее, хеш сообщения) в секретную степень $d$ по модулю $N$ для создания подписи, а любой проверяющий, обладая открытым ключом $(N,e)$, может возвести подпись в степень $e$ по модулю $N$ и проверить, что получается исходное сообщение (или его хеш).

RSA быстро завоевал известность как первый широко известный алгоритм ЭЦП (электронно-цифровой подписи). В 1978 году была опубликована первая научная статья, подробно описывающая RSA, а в 1983 году алгоритм был запатентован в США компанией MIT (права затем перешли к RSA Security). Несмотря на патентные ограничения (до их истечения в 2000 году), RSA внедрялся в прикладные системы: например, алгоритм использовался для подписания релизов ПО, в протоколе PGP для электронной почты (начало 1990-х), а позже стал частью стандартов SSL/TLS для защиты веб-трафика.

Дальнейшее развитие алгоритмов цифровой подписи. После RSA криптографическое сообщество исследовало и другие математические основы для подписи. В конце 1970-х Лесли Лэмпорт предложил схему одноразовой подписи (подпись Лэмпорта) на основе хеш-функций – она была проста, но позволяла подписать лишь одно сообщение на ключ, поэтому практического широкого применения не нашла, послужив скорее теоретическим ориентиром. В 1984 году Тахер Эль-Гамаль разработал новую схему цифровой подписи на основе сложности вычисления дискретного логарифма в конечном поле. Алгоритм Эль-Гамаля стал альтернативой RSA: вместо факторизации его безопасность опиралась на задачу дискретного логарифмирования (то есть нахождения $x$ из $g^x \mod p$). Схема Эль-Гамаля могла использоваться и для шифрования, и для подписи, однако подпись Эль-Гамаля имела некоторую избыточность и на практике применялась редко. Тем не менее, она заложила фундамент для более поздних усовершенствований. В 1989 году Клаус Шнорр предложил усовершенствованную подпись на основе дискретного логарифма – схема Шнорра – которая была эффективнее и короче, чем Эль-Гамаль, но, к сожалению, тоже была запатентована. Схема Шнорра стала известна минимальным размером подписи и быстрым вычислением, и впоследствии оказала влияние на стандартизацию.

Стандартизация цифровых подписей: появление DSA. В конце 1980-х – начале 1990-х назрела необходимость официального стандарта цифровой подписи для государственных и коммерческих информационных систем. В 1991 году Национальный институт стандартов и технологий США (NIST) выдвинул предложенный алгоритм DSA (Digital Signature Algorithm) в качестве основы стандарта цифровой подписи DSS. DSA основывался на идеях схемы Эль-Гамаля и Шнорра (фактически являя собой модификацию их подписи) и использовал задачу дискретного логарифма в мультипликативной группе простого модуля $p$. Существенное отличие DSA от RSA состояло в том, что DSA предназначен только для создания подписи и не пригоден для шифрования. В августе 1991 года предложение NIST вызвало обсуждение: некоторые специалисты критиковали выбор DSA, указывая, что к тому времени RSA уже стал де-факто стандартом в ПО, и переход на другой алгоритм потребует усилий. Также ходили слухи, что алгоритм DSA был разработан при участии Агентства национальной безопасности (АНБ) США, что вызывало осторожность. Тем не менее, после публичного обсуждения DSA был утверждён: в 1994 году опубликован федеральный стандарт FIPS 186 (Digital Signature Standard), закрепивший DSA в качестве стандарта ЭЦП для государственных систем. Поскольку RSA в те годы был обременён патентами, переход на свободно лицензируемый DSA был стратегически выгоден. Первая версия DSS (FIPS-186-1) поддерживала ключи длины 512–1024 бит (модуль $p$) с 160-битным параметром $q$. Позднее стандарт пересматривался: в 2000 г. (FIPS-186-2) были уточнены некоторые детали и добавлена возможность других параметров; в 2009 и 2013 вышли FIPS-186-3/4, увеличившие допустимую длину ключей (например, $p$ до 2048 и 3072 бит, $q$ до 256 бит для повышения уровня безопасности). Однако со временем выяснилось, что DSA менее гибок – размер подписи всегда 320 бит (для 160-битного $q$) или больше с увеличением $q$, а скорость ниже, чем у RSA при проверке подписи. Тем не менее, DSA получил распространение в программном обеспечении с открытым кодом (например, OpenSSL, GnuPG). Спустя десятилетия алгоритм DSA начал уходить в прошлое: в новейшей версии стандарта (FIPS 186-5, 2023 г.) рекомендовано отказаться от использования DSA для генерации новых подписей, допуская его лишь для проверки старых. Современные системы переходят на более эффективные и безопасные схемы, о чём будет сказано далее.

Эллиптические кривые и алгоритм ECDSA. Ещё одним ключевым этапом развития цифровых подписей стало применение криптографии на эллиптических кривых. В 1985 году независимо два математика – Виктор Миллер и Нил Коблиц – предложили использовать эллиптические кривые над конечными полями для построения криптосистем. Изначально идея не получила широкого распространения: реализация эллиптической криптографии требовала большего понимания и вычислительных ресурсов, и до конца XX века она оставалась скорее перспективой, чем массовой практикой. Ситуация изменилась после стандартизации DSA. В 1992 году канадский криптограф Скотт Ванстоун опубликовал работу под названием “Responses to NIST’s proposal”, в которой предложил аналог алгоритма DSA, использующий группы точек на эллиптических кривых вместо классической группы по модулю $p$. Так появился алгоритм ECDSA (Elliptic Curve DSA) – эллиптическая версия DSA. ECDSA сочетал принцип DSA (использование случайного секрета $k$ для каждого подписания и вычисление пар $(r,s)$) с преимуществами эллиптических кривых – при той же стойкости размер ключей и подписи оказался существенно меньше. В конце 1990-х ECDSA прошёл стандартизацию: в 1998 году он был включён в стандарт ISO 14888-3, в январе 1999 принят как американский стандарт ANSI X9.62, а в 2000 году добавлен в стандарт IEEE 1363 и в пересмотр стандарта FIPS 186-2. Таким образом, примерно к 2000 году ECDSA стал одним из официальных алгоритмов цифровой подписи наряду с классическим DSA и RSA.

Последующие события и современное состояние. На рубеже тысячелетий сложился набор из трёх основных алгоритмов цифровой подписи: RSA, DSA и ECDSA, каждый со своими областями применения. RSA широко использовался в интернет-протоколах (TLS, SSL, S/MIME) и инфраструктуре PKI, DSA – в государственных системах и открытом ПО, ECDSA начал применяться в мобильных и встраиваемых системах, а впоследствии – в криптовалютах (биткойн с 2009 года использует ECDSA с кривой secp256k1 для подписей транзакций). В 2000-х годах продолжалось развитие: появились вариации и новые схемы. Например, в 2001 году по российскому стандарту был принят алгоритм ГОСТ Р 34.10-2001, представляющий собой схему подписи на эллиптических кривых, параллельно мировому ECDSA. В 2014 году были опубликованы схемы EdDSA (на кривых Эдвардса, в частности Ed25519), которые предоставляют ещё более быстрые и компактные подписи; они постепенно набирают популярность и рассматриваются как будущее цифровых подписей. Также большое внимание уделяется постквантовым цифровым подписям – то есть алгоритмам, устойчивым к атакам с использованием квантовых компьютеров (примером являются схемы на основе решёток и многоразовых хеш-цепочек). Тем не менее, по состоянию на середину 2020-х годов RSA и ECDSA остаются доминирующими в практике, обеспечивая безопасность большинства систем. Стандартизация продолжает совершенствоваться: уже упомянутый FIPS 186-5 (2023) помимо вывода DSA из обращения рекомендует перейти на современные схемы (такие как EdDSA) и увеличивает минимальные размеры ключей RSA (например, 3072 бит вместо 2048 для долгосрочной безопасности).

Подводя итог историческому обзору, отметим ключевые этапы развития цифровых подписей: - 1976: формулировка концепции асимметричной криптографии и цифровой подписи (Диффи, Хеллман). - 1977: создание RSA – первого практического алгоритма цифровой подписи (Ривест, Шамир, Адлеман). - 1979–1984: исследования других схем подписи – подписи на хеш-функциях (Лэмпорт), схема Эль-Гамаля (1984). - 1989: появление эффективной подписи Шнорра (патентована, но повлияла на стандарты). - 1991–1994: разработка и стандартизация алгоритма DSA (стандарт DSS/FIPS-186). - 1998–2000: стандартизация алгоритма ECDSA на основе эллиптических кривых (ANSI X9.62, IEEE 1363, FIPS-186-2). - 2000-е: широкое внедрение RSA и ECDSA в протоколы и системы, принятие национальных стандартов (например, российский ГОСТ на ЭЦП). - 2010-е: появление новых схем (EdDSA) и начало перехода к ним; активные исследования постквантовых подписей. - 2020-е: пересмотр стандартов (отказ от устаревшего DSA, повышение требований к RSA), внедрение новых алгоритмов на практике.

Таким образом, цифровые подписи прошли путь от теоретической идеи до неотъемлемой части современной кибербезопасности. Далее, в Главе 2, подробно рассмотрим математическую основу и принципы работы основных алгоритмов: RSA, DSA и ECDSA.

Глава 2. Подробное описание алгоритмов RSA, DSA и ECDSA

В этой главе рассматриваются три ключевых алгоритма цифровой подписи – RSA, DSA и ECDSA. Для каждого из них описаны математические основы, используемые параметры, процесс генерации ключей, создание подписи и её проверка. Приведены формулы и небольшие примеры вычислений для иллюстрации работы алгоритмов.

2.1 Алгоритм RSA

Общее описание и математическая основа. RSA – это алгоритм с открытым ключом, безопасность которого базируется на сложности факторизации больших целых чисел. Имеется в виду, что при известных $N = p \cdot q$ (произведении двух больших простых чисел $p$ и $q$) не существует эффективного способа найти сами множители $p$ и $q$. Секретный ключ RSA связан с факторизацией модуля $N$: зная разложение $N$ на множители, можно вычислить секретную «расшифровывающую» экспоненту $d$. При этом сторонний наблюдатель, не умеющий факторизовать $N$, не сможет вычислить $d$ за разумное время. Алгоритм RSA позволяет как шифровать данные, так и подписывать сообщения. В контексте цифровой подписи RSA работает следующим образом: подписывающий обладает закрытым ключом $(d)$, а проверяющий – соответствующим открытым ключом $(N, e)$. Здесь $N$ – модуль (произведение двух секретных простых чисел), $e$ – публичная экспонента (обычно небольшое целое, например 65537), а $d$ – секретная экспонента, удовлетворяющая условию $d \cdot e \equiv 1 \pmod{\varphi(N)}$ (то есть $d$ является мультипликативным обратным к $e$ по модулю функции Эйлера $\varphi(N)$). Цифровая подпись сообщения $M$ в простейшем случае представляет собой вычисление $S = M^d \bmod N$. Для проверки подписи вычисляют $S^e \bmod N$ и проверяют, совпадает ли результат с оригинальным сообщением $M$. Поскольку обычно само сообщение бывает длинным, на практике подписывают не $M$ напрямую, а его хеш-значение $H(M)$ фиксированной длины (например, 256 бит), что решает проблему размеров и повышает безопасность. Формально, при проверке убеждаются, что $S^e \bmod N = H(M)$.

Генерация ключей RSA. Генерация ключевой пары RSA включает следующие шаги: 1. Выбор простых чисел. Случайным образом выбираются два больших простых числа $p$ и $q$ примерно одинакового размера. Разрядность $p$ и $q$ выбирается исходя из желаемой длины модуля $N$. Для современных уровней безопасности часто берут 1024-битные $p$ и $q$, чтобы $N$ было ~2048 бит. Требования: $p \neq q$, оба числа простые, случайно выбранные (для непредсказуемости). 2. Вычисление модуля. Вычисляется $N = p \cdot q$. Число $N$ – модуль – публикуется в открытом ключе. 3. Вычисление функции Эйлера. Вычисляется значение $\varphi(N) = (p-1)(q-1)$. Это количество чисел, меньших $N$, взаимно простых с $N$. $\varphi(N)$ остаётся в секрете, так как раскрытие $\varphi(N)$ упростило бы вычисление $d$. 4. Выбор открытой экспоненты. Выбирается целое число $e$ – открытая экспонента. Обычно её берут небольшой и фиксированной для удобства. Популярный выбор – $e=65537$ (то есть $2^{16}+1$) из соображений эффективности. Важно, чтобы $e$ было взаимно просто с $\varphi(N)$ (то есть $\gcd(e, \varphi(N)) = 1$). 5. Вычисление закрытой экспоненты. Находится число $d$ – мультипликативное обратное к $e$ по модулю $\varphi(N)$. Иными словами, $d$ удовлетворяет уравнению $d \cdot e \equiv 1 \pmod{\varphi(N)}$. Это уравнение решается расширенным алгоритмом Евклида, который находит обратный элемент. Число $d$ – закрытый ключ, хранится в тайне. Пара $(N, e)$ образует открытый ключ, публикуемый для всех желающих проверить подпись.

После этих шагов у пользователя имеется ключевая пара RSA. Секретом являются простые $p, q$ (часто после вычисления ключей они уничтожаются) и вычисленный $d$. Открыто публикуется $(N, e)$.

Процедура подписи RSA. Чтобы подписать сообщение $M$, выполняются действия: 1. Вычисляется хеш сообщения $h = H(M)$ с помощью криптографической хеш-функции (например, SHA-256). Если сообщение короткое, на учебных примерах шаг с хешированием могут опускать, но в реальных системах он обязателен. 2. Полученный хеш $h$ интерпретируется как число (меньшее $N$). Далее вычисляется подпись $S$ как возведение $h$ в степень $d$ по модулю $N$: $$ S = h^d \bmod N. $$ Это основная операция «шифрования подписи» закрытым ключом. 3. Полученное значение $S$ – и есть цифровая подпись. Она передаётся получателю вместе с оригинальным сообщением (либо вместо сообщения, если оно уже известно проверяющему, например, в случае подписи сертификата).

Важно отметить, что на практике к $h$ перед возведением в степень применяется форматирование (например, схема PKCS#1 v1.5 или PSS), чтобы предотвратить определённые атаки. Но в базовом описании мы опускаем детали форматирования.

Процедура проверки RSA. Любой проверяющий, имея открытый ключ $(N, e)$ автора подписи и получив сообщение $M$ и подпись $S$, выполняет: 1. Вычисление собственного хеша сообщения: $h_{\text{calc}} = H(M)$. 2. Возведение полученной подписи $S$ в степень $e$ по модулю $N$: $$ h_{\text{recv}} = S^e \bmod N. $$ 3. Сравнение $h_{\text{recv}}$ с $h_{\text{calc}}$. Если они совпали, то проверяющий убеждается, что подпись корректна: действительно существует число $d$, известное только подписанту, такое что $S = h^d \bmod N$, и, следовательно, сообщение подписано владельцем закрытого ключа. Совпадение также означает, что сообщение не было искажено (иначе хеш бы отличался).

Если же $S^e \not\equiv H(M) \pmod{N}$, проверка проваливается – подпись недействительна (сообщение могло быть подменено или подписано кем-то другим).

Пример вычислений (RSA). Для иллюстрации возьмём небольшие числа (в реальности они намного больше): - Пусть простые $p=61$, $q=53$. Тогда $N = p\cdot q = 3233$. Вычислим $\varphi(N) = (61-1)(53-1) = 3120$. - Выберем открытую экспоненту $e=17$ (она взаимно проста с 3120). Найдём $d$ такое, что $17d \equiv 1 \pmod{3120}$. Получаем $d = 2753$ (проверка: $17 \cdot 2753 = 46801$, и $46801 \mod 3120 = 1$). - Открытый ключ: $(N=3233,\ e=17)$. Закрытый ключ: $d=2753$ (держится в секрете). - Допустим, необходимо подписать сообщение, представимое числом $M=123$ (например, $H(M)=123$ для простоты). Вычисляем подпись: $S = 123^{2753} \bmod 3233$. Вручную такое возведение не сделать, но с помощью компьютерного расчёта получим $S = 2746$. - Передаём получателю $M=123$ и $S=2746$. Получатель вычисляет $H(M)=123$ и проверяет: $S^e \bmod 3233 = 2746^{17} \bmod 3233$. Возведение 2746 в 17-ю степень по модулю 3233 возвращает 123, что совпадает с $H(M)$. Таким образом, подпись верна.

На практике, разумеется, RSA используют с числами в сотни десятичных знаков, и все операции выполняются программно. Тем не менее, принцип остаётся тем же: секретное возведение в степень для создания подписи и публичное возведение в степень для проверки.

Размеры и параметры RSA. Безопасность RSA растёт с длиной модуля $N$. Сегодня минимально рекомендуемым считается модуль 2048 бит, а для долгосрочной безопасности – 3072 бита и более. Открытая экспонента обычно выбирается стандартной ($3$, $65537$ и т.п.) и не влияет на безопасность значимо. Закрытая экспонента автоматически имеет размер порядка $\varphi(N)$. Размер цифровой подписи RSA равен размеру модуля $N$ (в байтах). Например, при 2048-битном ключе RSA подпись – 256 байт (2048 бит). Это больше, чем у алгоритмов на эллиптических кривых при аналогичной стойкости, что является одним из недостатков RSA. Скорость операций также разнится: создание подписи RSA (возведение в степень $d$) обычно медленнее, чем проверка (возведение в степень $e$, где $e$ мало). Тем не менее, RSA остаётся популярным благодаря своей концептуальной простоте и широкому внедрению.

2.2 Алгоритм DSA (Digital Signature Algorithm)

Общее описание и основы DSA. DSA – это стандартный алгоритм цифровой подписи, основанный на задаче дискретного логарифма в конечном поле. В отличие от RSA, он не предназначен для шифрования или обмена ключами – только для подписи. Математически DSA использует свойства мультипликативной группы вычетов по модулю $p$ (где $p$ – большое простое). Безопасность обеспечивается тем, что вычислить дискретный логарифм – то есть найти такое $x$, чтобы $g^x \equiv y \pmod p$ – вычислительно сложно, если $p$ большое. Закрытый ключ DSA – это число $x$ (аналогичное экспоненте), а открытый ключ – число $y = g^x \bmod p$. Здесь $g$ – генератор (образующий элемент) небольшой мультипликативной группы порядка $q$ по модулю $p$. В целом, DSA генерирует подпись, состоящую из двух чисел $(r, s)$, вычисленных с использованием случайного секретного параметра для каждого сообщения. Это отличие от RSA: одна и та же $d$ в RSA даёт всегда одинаковую подпись для одинакового $M$ (если не использовать случайные паддинги), а DSA принципиально требует нового случайного параметра на каждое подписываемое сообщение.

Параметры DSA. Для работы алгоритма DSA требуется заранее сгенерировать набор доменных параметров: - Простое число $q$ – порядок меньшей подгруппы. По стандарту $q$ должен быть порядка 160–256 бит. Изначально (DSS 1994) $q=160$ бит (примерно $10^{48}$), позже допущены 224 и 256 бит. - Простое число $p$ – модуль, такой что $p-1$ делится на $q$. То есть, $q$ является простым делителем $p-1$. Длина $p$ обычно 1024 бита (исторически), либо 2048 или 3072 бита в более современных параметрах. - Число $g$ – генератор подгруппы порядка $q$ в мультипликативной группе по модулю $p$. Иными словами, $g^{q} \equiv 1 \pmod p$, и порядок $g$ равен именно $q$. Чтобы найти $g$, обычно берут какое-то число $h$ и возводят в степень $(p-1)/q$: $$ g = h^{(p-1)/q} \bmod p. $$ При подходящем $h$ (например, $h$ – примитивный элемент группы мод $p$) результат будет иметь порядок $q$. В большинстве случаев можно взять $h=2$ и проверить $g \neq 1$. - Криптографическая хеш-функция $H$. Размер выхода хеша должен совпадать с размером $q$ (если он больше, берутся младшие биты). В оригинальном стандарте была зафиксирована SHA-1 (160 бит), позднее разрешили SHA-224, SHA-256 при большем $q$.

Эти параметры $(p, q, g, H)$ могут быть общими для группы пользователей или системы. Их можно сгенерировать централизованно, опубликовать и затем разные пользователи будут создавать свои ключи в рамках этих параметров.

Генерация ключей DSA (пользовательских). После определения доменных параметров каждый пользователь генерирует свою пару ключей: 1. Выбирается случайное число $x$ в диапазоне $1 \le x \le q-1$. Это закрытый ключ (секретный параметр пользователя). 2. Вычисляется соответствующий открытый ключ $y$ как $$ y = g^x \bmod p. $$ Это аналогично возведению в степень при RSA, но здесь используется модуль $p$ и основание $g$. Значение $y$ публикуется.

Заметим, что $y^q \equiv g^{xq} \equiv (g^q)^x \equiv 1^x \equiv 1 \pmod p$, то есть $y$ действительно лежит в подгруппе порядка $q$.

Создание цифровой подписи (DSA). Чтобы подписать сообщение $M$ с помощью DSA, выполняются следующие шаги: 1. Вычисляется хеш сообщения: $h = H(M)$. Обычно $h$ трактуется как целое число (в диапазоне от $0$ до $2^{|q|}-1$). Если хеш длиннее $q$, то берутся только первые (старшие) $|q|$ бит хеша. 2. Генерируется случайное число $k$ в диапазоне $1 \le k \le q-1$. Это эпhemeral key, одноразовый секрет для данной подписи. Число $k$ должно оставаться секретным, его раскрытие поставит под угрозу $x$ (см. уязвимости DSA). Важно: нельзя повторно использовать одно и то же $k$ для разных сообщений, иначе безопасность теряется. 3. Вычисляется значение $$ r = (g^k \bmod p) \bmod q. $$ То есть сначала считается $g^k$ по модулю $p$, затем результат берётся по модулю $q$. Число $r$ – первое компонент подписи. Если получилось $r=0$, то выбирают другое $k$ и повторяют (но вероятность $r=0$ крайне мала, порядка $1/q$). 4. Вычисляется значение, связанное с хешем и закрытым ключом: $$ s = k^{-1} \cdot (h + x \cdot r) \bmod q. $$ Здесь $k^{-1}$ – мультипликативное обратное к $k$ по модулю $q$. То есть $k \cdot k^{-1} \equiv 1 \pmod q$. Обратный элемент существует, так как $k$ выбрали взаимно простым с $q$ (в диапазоне $1..q-1$). Вычислить $k^{-1}$ можно расширенным алгоритмом Евклида. После нахождения $s$ проверяют: если $s = 0$, также заново генерируют другой $k$ (снова, вероятность практически нулевая). 5. Пара $(r, s)$ образует цифровую подпись сообщения. Эта подпись отсылается получателю (вместе с $M$ или отдельно).

Стоит обратить внимание: компоненты $r$ и $s$ – это числа порядка $q$ (например, 160-битные), то есть значительно меньше, чем модуль $p$. Тем самым подпись относительно компактна: два числа размером, равным размеру хеша. Для сравнения, RSA-подпись имеет размер порядка $p \approx 1024$–2048 бит. Поэтому DSA-подписи были привлекательны компактностью.

Проверка цифровой подписи (DSA). Получив сообщение $M$ и подпись $(r, s)$, а также зная открытый ключ отправителя $y$, проверяющий выполняет: 1. Удостоверяется, что $0 < r < q$ и $0 < s < q$. Если нет, подпись сразу считается недействительной. 2. Вычисляет хеш полученного сообщения: $h_{\text{calc}} = H(M)$, и трактует его как число (при необходимости усекает до длины $q$ бит). 3. Вычисляет вспомогательное значение $$ w = s^{-1} \bmod q, $$ то есть мультипликативную обратную к $s$ по модулю $q$. Это число тоже можно получить алгоритмом Евклида. 4. Вычисляет два значения: $$ u_1 = (h_{\text{calc}} \cdot w) \bmod q, $$ $$ u_2 = (r \cdot w) \bmod q. $$ Оба $u_1, u_2$ – числа в диапазоне $0..q-1$. 5. Вычисляет точечное значение: $$ v = \big( g^{u_1} \cdot y^{u_2} \bmod p \big) \bmod q. $$ Здесь сначала вычисляется $g^{u_1} \cdot y^{u_2} \bmod p$ (то есть перемножение двух больших степеней по модулю $p$), а затем результат снова берётся по модулю $q$, чтобы получить число, сравнимое с $r$. 6. Сравнивает $v$ и $r$. Если $v = r$, то подпись считается подлинной (принимается). Иначе – отвергается как некорректная.

Почему этот алгоритм проверки работает? Если подпись $(r,s)$ была правильно создана подписантом, то можно показать, что $v$ вычисленный совпадёт с исходным $r$. Действительно, подставим $s = k^{-1}(h + xr)$ и проследим преобразования: при проверке $v = (g^{u_1} y^{u_2} \bmod p) \bmod q$. Подставляя $y = g^x$ и $u_1 = h w$, $u_2 = r w$, получим: $$ g^{u_1} y^{u_2} = g^{h w} \cdot (g^x)^{r w} = g^{h w + x r w}. $$ А так как $w = s^{-1} = k / (h + x r)$ (из уравнения для $s$), то $$ h w + x r w = h \frac{k}{h+xr} + x r \frac{k}{h+xr} = k. $$ Таким образом, $$ g^{u_1} y^{u_2} \bmod p = g^k \bmod p. $$ По определению алгоритма подписания, $g^k \bmod p$ при взятии по модулю $q$ даст именно $r$. Следовательно, $v = r$. Этот вывод демонстрирует корректность схемы DSA.

Пример вычислений (DSA). Возьмём небольшие числа для примера (они не соответствуют реальным уровням безопасности, но иллюстрируют механизм): - Доменные параметры: $p = 283$, $q = 47$. Эти числа удовлетворяют: $p-1 = 282$ делится на $q=47$ (действительно, $282/47=6$). Возьмём $g = 60$ – оказывается, $60^{47} \mod 283 = 1$, то есть $g$ имеет порядок 47 (проверяется, что меньшей степени, кроме 47, дающей 1 нет – мы это предполагаем). - Криптографическая хеш-функция в примере не вычисляем, а зададим "искусственно": пусть $H(M) = 41$ для некоторого сообщения $M$ (такое число меньше $q=47$). - Генерация ключей: выбираем закрытый ключ $x = 24$ (любой в [1,46]). Тогда открытый ключ $y = g^x \mod p = 60^{24} \mod 283$. Вычисление даст $y = 158$ (найдено заранее или с помощью компьютера). Итак, приватный ключ $x=24$, публичный $y=158$. - Подпись сообщения: вычисляем $h = 41$ (хеш задан). Выбираем случайный секрет $k = 15$. Далее: - $r = (g^k \bmod p) \bmod q = 60^{15} \bmod 283$. Вычисления: $60^{15} \mod 283 = 207$. Затем $207 \mod 47 = 19$. Итак, $r = 19$. - Вычисляем обратное к $k$ по модулю $q$: нужно $15^{-1} \mod 47$. Решаем $15 \cdot k^{-1} \equiv 1 \pmod{47}$. Подбор или алгоритм Евклида даёт $15^{-1} \equiv 22$ (проверка: $15 \cdot 22 = 330$, $330 \mod 47 = 1$). - Теперь вычисляем $s = k^{-1}(h + x r) \bmod q = 22 \cdot (41 + 24 \cdot 19) \mod 47$. Считаем внутри: $24 \cdot 19 = 456$, плюс $41$ даёт $497$. Теперь $497 \mod 47 = 497 - 47\cdot10 = 497 - 470 = 27$. Затем умножаем на $22$: $22 \cdot 27 = 594$. И $594 \mod 47 = 594 - 47 \cdot 12 = 594 - 564 = 30$. Таким образом, $s = 30$. - Подписью является пара $(r, s) = (19, 30)$. - Проверка подписи: проверяющий знает $p, q, g, y=158$. Он вычисляет $h = H(M) = 41$. - Проверяет диапазон: $r=19, s=30$ находятся в $[1,46]$, всё нормально. - Вычисляет $w = s^{-1} \mod 47$. Нужно обратное к $30$ по модулю $47$. Решаем $30 \cdot w \equiv 1 \pmod{47}$. Например, проверяя несколько, найдём $w = 11$ (потому что $30 \cdot 11 = 330$, а $330 \mod 47 = 330 - 47\cdot7 = 330 - 329 = 1$). - Находит $u_1 = (h \cdot w) \mod 47 = 41 \cdot 11 \mod 47 = 451 \mod 47$. $47 \cdot 9 = 423$, остаток $451 - 423 = 28$, так что $u_1 = 28$. - Вычисляет $u_2 = (r \cdot w) \mod 47 = 19 \cdot 11 \mod 47 = 209 \mod 47$. $47 \cdot 4 = 188$, остаток $209 - 188 = 21$, получаем $u_2 = 21$. - Вычисляет $X = g^{u_1} \cdot y^{u_2} \mod p$. Это два степенных возведения: $g^{28} \mod 283$ и $y^{21} \mod 283$, затем перемножение и ещё модуль 283. Предварительно можно вычислить: $g^{28} = 60^{28} \mod 283$, $y^{21} = 158^{21} \mod 283$. Для простоты предположим, что произведение даёт $X = 207$ (что совпадает с $g^{15}$ как должно). Далее $v = X \mod 47 = 207 \mod 47 = 19$. - Сравнивает $v$ с $r$: $19$ против $19$ – совпадают, значит подпись верна.

Хотя в этом примере мы опустили некоторые вычислительные подробности, он иллюстрирует характерные черты DSA: использование случайного $k$, два числа $(r, s)$ в подписи и успешную верификацию благодаря правильному подбору $k^{-1}$.

Особенности и безопасность DSA. При правильном выборе параметров (достаточная длина $p$ и $q$) стойкость DSA эквивалентна стойкости вычисления дискретного логарифма. На 2020-е годы рекомендуются параметры $p$ длиной не менее 2048 бит и $q$ длиной 256 бит (дающие уровень безопасности порядка 112–128 бит). Очень важным требованием является непредсказуемость параметра $k$ для каждой подписи. Если злоумышленник узнает или угадает $k$, он сможет из уравнения $s = k^{-1}(h + xr) \mod q$ вычислить секретный ключ $x$. Именно поэтому стандарты требуют использовать криптографически стойкий генератор случайных чис для $k$. Известен инцидент с уязвимостью Sony PlayStation 3 (2010 г.), когда при подписи прошивок использовались повторяющиеся или предсказуемые значения $k$, что позволило взломать электронную подпись и подделывать обновления прошивки.

2.3 Алгоритм ECDSA (Elliptic Curve DSA)

Общее описание и математическая идея. ECDSA является вариантом алгоритма DSA, в котором вместо группы по модулю $p$ используется группа точек эллиптической кривой над конечным полем. Эллиптические кривые обладают тем свойством, что задача дискретного логарифма на них (называемая ECDLP, проблема дискретного логарифма на эллиптической кривой) значительно сложнее при тех же размерах чисел, чем в случае обычных модулей. Это позволяет получать ту же криптографическую стойкость при гораздо меньшей длине ключей и параметров. В основе ECDSA лежит та же схема подписи с использованием случайного секретного параметра для каждого сообщения, но операции умножения и возведения в степень заменяются операциями над точками эллиптической кривой.

Параметры эллиптической кривой. Для алгоритма ECDSA необходимо определить следующие доменные параметры: - Конечное поле $\mathbb{F}_q$ – обычно берётся простое поле $\mathbb{F}_p$ (где $p$ – большое простое) либо двоичное поле $GF(2^m)$. Мы рассмотрим случай $\mathbb{F}_p$. Размер поля определяет разрядность координат точек. - Уравнение эллиптической кривой над этим полем. Стандартная форма – уравнение Вейерштрасса: $$ E: y^2 \equiv x^3 + a x + b \pmod p, $$ где коэффициенты $a$ и $b$ заданы и удовлетворяют условию невырожденности (конкретное значение, чтобы кривая не имела особых точек: $4a^3 + 27b^2 \not\equiv 0 \pmod p$). - Точка генератор $G = (x_G, y_G)$ на кривой $E$ – выбранная фиксированная точка, обладающая большим порядком. Порядок точки $G$ – это наименьшее положительное число $n$, такое что $nG = \mathcal{O}$ (нулевая точка, "бесконечно удалённая"). В параметрах указывается порядок $n$. - Порядок подгруппы $n$. В ECDSA, аналогично DSA, используется подгруппа большого простого порядка $n$. Обычно $n$ само является простым. (Количество всех точек на кривой может быть больше, но $n$ – это порядок именно выбранного генератора $G$). - Коэффициент соотношения $h$ – называемый cofactor, равен отношению общего числа точек на кривой к порядку $n$. Во многих случаях $h=1$ (когда количество точек ровно $n$, кривая имеет простое порядка подгруппы). Если $h>1$, его учитывают в некоторых вычислениях. - Криптографическая хеш-функция $H$ для вычисления хеша сообщений (как и в DSA).

Параметры эллиптических кривых для ECDSA стандартизированы различными организациями. Существуют известные наборы: например, NIST P-256 – кривая над полем 256-битного простого числа, secp256k1 – кривая, используемая в биткойне, RFC 5639 Brainpool curves и др. В этих стандартах заданы конкретные $p, a, b, G, n, h$. Пользователям обычно не нужно генерировать свою собственную кривую – они пользуются рекомендованной.

Генерация ключей ECDSA. После выбора параметров кривой каждый пользователь создаёт свою пару ключей: 1. Выбирается случайное целое $d$ в диапазоне $[1, n-1]$. Это закрытый ключ (скаляр, аналог $x$ в DSA или $d$ в RSA, но не следует путать с $d$ RSA – здесь другое значение). 2. Вычисляется соответствующий открытый ключ – точка $Q$ на кривой: $$ Q = d \cdot G, $$ то есть суммируется $G$ с собой $d$ раз (точечное умножение на скаляр). В результате $Q = (x_Q, y_Q)$ – точка на кривой. Значение $Q$ публикуется как открытый ключ. Закрытый ключ $d$ держится в секрете.

Смысл этого шага: получить $Q$, зная $d$, легко (просто многократным сложением точек), а обратная задача – по $G$ и $Q$ найти $d$ – это и есть сложная задача дискретного логарифма на кривой (ECDLP). При надёжно выбранных параметрах и достаточном размере $n$ она вычислительно неразрешима.

Создание цифровой подписи (ECDSA). Алгоритм подписывания очень похож на DSA, с той лишь разницей, что вычисления $(g^k \bmod p)$ заменяются вычислением точки $kG$ на кривой: 1. Вычисляется хеш сообщения: $h = H(M)$, трактуемый как целое число. Если битовая длина хеша больше, чем битовая длина $n$, то хеш обрезается до длины $\lfloor \log_2 n \rfloor + 1$ бит (т.е. до длины порядка группы). 2. Генерируется случайное число $k$ в диапазоне $[1, n-1]$ – временный секрет для данной подписи (аналогичный $k$ в DSA). Требования к нему те же: случайность, неповторяемость, секретность. 3. Вычисляется точка $R = k \cdot G$ на кривой (умножение точки $G$ на скаляр $k$). Пусть координаты этой точки $R = (x_1, y_1)$. 4. Вычисляется $$ r = x_1 \bmod n. $$ Координата $x_1$ берётся по модулю $n$ (на практике, поскольку $x_1 < p$ и $p$ обычно больше $n$, часто просто берут $r = x_1$ если $x_1$ уже меньше $n$). Если получилось $r = 0$, переходят к новому случайному $k$ (вероятность этого очень мала, порядка $1/n$). 5. Вычисляется $$ s = k^{-1} \cdot (h + d \cdot r) \bmod n. $$ Здесь $k^{-1}$ – мультипликативная обратная по модулю $n$. Это похоже на формулу DSA. Если $s = 0$, также выбирается другой $k$ (вероятность этого тоже пренебрежимо мала). 6. Пара $(r, s)$ является цифровой подписью сообщения.

Подчеркиваем, что все операции с координатами происходят в поле $\mathbb{F}_p$ (например, сложение точек – по модулю $p$, вычисление $k^{-1}$ – по модулю $n$). Координата $x_1$ – элемент поля $\mathbb{F}_p$, но мы интерпретируем её как обычное число и берем по модулю $n$.

Проверка цифровой подписи (ECDSA). Имея открытый ключ $Q$ (точка на кривой) подписанта, подпись $(r, s)$ и сообщение $M$, проверяющий выполняет: 1. Проверяет, что $r$ и $s$ находятся в диапазоне $[1, n-1]$. Если нет – подпись недействительна сразу. 2. Вычисляет $h = H(M)$ (хеш сообщения), при необходимости усекает его до длины группы $n$ (как описано ранее). 3. Вычисляет $$ w = s^{-1} \bmod n. $$ (Обратный элемент $s$ по модулю $n$ – аналог $w$ как в DSA). 4. Вычисляет $$ u_1 = (h \cdot w) \bmod n, $$ $$ u_2 = (r \cdot w) \bmod n. $$ Оба $u_1, u_2$ – числа в диапазоне $0..n-1$. 5. Вычисляет новую точку $$ X = u_1 \cdot G + u_2 \cdot Q. $$ Здесь берётся линейная комбинация точек: $G$ умножается на $u_1$, $Q$ умножается на $u_2$, потом эти точки складываются. Геометрически это означает $X = (h/s)G + (r/s)Q$ в упрощенной форме. 6. Если $X$ – точка на бесконечности $\mathcal{O}$ (нулевая точка), то подпись отвергается (такое может случиться, если например $r$ или $s$ ноль или некорректны). 7. Иначе, пусть $X = (x_2, y_2)$ – полученная точка. Вычисляет $$ v = x_2 \bmod n. $$ 8. Сравнивает $v$ и $r$. Если $v = r$, то подпись считается правильной. В противном случае – неверна.

Корректность проверки ECDSA доказывается аналогично DSA: если подставить $s = k^{-1}(h + dr)$ и учесть $Q = dG$, то получается в шаге 5: $$ X = u_1 G + u_2 Q = (h w)G + (r w)(dG) = (h + dr)w G = k G, $$ так как $w = s^{-1} = k/(h+dr)$. Таким образом $X = kG = R$, и его координата $x_2$ равна исходному $x_1$, давая $v = r$.

Пример вычислений (ECDSA). Рассмотрим небольшую искусственную кривую для демонстрации. Пусть поле $\mathbb{F}_{11}$ (то есть все вычисления по модулю $p=11$). Возьмём кривую $$ y^2 = x^3 + x + 6 \pmod{11}. $$ Эта кривая имеет конечное множество точек. Для неё можно найти точку генератора. Например, точка $G = (7, 9)$ лежит на кривой (проверяется: $9^2 = 81 \equiv 4 \pmod{11}$, а $7^3 + 7 + 6 = 350 \equiv 4 \pmod{11}$, сходится). Выясняется, что у этой кривой число точек $n = 13$ (включая точку на бесконечности), и выбранная точка $G$ имеет порядок 13, то есть генерирует всю группу точек. Тогда параметры: $p=11$, уравнение как выше с $a=1$, $b=6$, генератор $G(7,9)$, порядок $n=13$, cofator $h=1$. Предположим, хеш-функция просто выдаёт число от 0 до 12 (для простоты берем небольшие значения вручную).

Генерация ключей: Выбираем закрытый ключ $d = 5$ (в диапазоне [1,12]). Тогда открытый ключ $Q = d \cdot G$. Нужно сложить точку $G$ сама с собой 5 раз (или умножить 5 на $G$). Предварительно: $2G = (7,9)+(7,9)$, $3G = 2G+G$ и т.д. Предположим, получаем $Q = 5G = (10,2)$ (эту точку можно вычислить вручную с помощью формул сложения точек или программно).

Подпись сообщения: Пусть требуемый хеш сообщения $M$ равен, например, $h = 7$. Выбираем случайное $k = 3$. Вычисляем $R = kG = 3G$. Сложая точку $G$ трижды: $2G = (8,3)$, $3G = (...)$ – доверимся вычислениям, предположим $3G = (x_1,y_1) = (3, * )$ (точное значение $y$ не критично). Тогда $x_1 = 3$. Вычисляем $r = x_1 \bmod 13 = 3$. Затем находим $k^{-1}$ по модулю 13: для $k=3$ обратное число $3^{-1} \mod 13$ равно $9$, потому что $39=27 \equiv 1 \pmod{13}$. Теперь вычисляем $$ s = 9 \cdot (7 + 5 \cdot 3) \bmod 13. $$ Внутри: $5 \cdot 3 = 15$, плюс $7$ это $22$. $22 \bmod 13 = 9$. Умножаем на $9$: $9 \cdot 9 = 81$. $81 \bmod 13 = 81 - 136 = 81 - 78 = 3$. Получаем $s = 3$. Подпись равна $(r, s) = (3, 3)$.

Проверка подписи: Проверяющий получил $(r=3, s=3)$ и знает $Q=(10,2)$. Он вычисляет хеш $h = 7$. Проверяет диапазон $r, s$ (оба от 1 до 12, нормально). Находит $w = s^{-1} \mod 13$. $s=3$, обратное к $3$ по модулю $13$ – как мы нашли, $3^{-1} = 9$. Затем $$ u_1 = (h \cdot w) \mod 13 = 7 \cdot 9 \mod 13 = 63 \mod 13 = 11, $$ поскольку $13*4 = 52$, остаток $63-52=11$. $$ u_2 = (r \cdot w) \mod 13 = 3 \cdot 9 \mod 13 = 27 \mod 13 = 1. $$ Теперь вычисляется точка $$ X = 11 \cdot G + 1 \cdot Q = 11G + Q. $$ Поскольку $12G$ было бы точка на бесконечности (порядок 13), $11G$ равна $-G$ (обратная к $G$ точка). $G=(7,9)$, тогда $-G$ будет $(7, -9 mod 11) = (7, 2)$ (потому что $9+2=11 \equiv 0$). То есть $11G = (7,2)$. Далее $X = 11G + Q = (7,2) + (10,2)$. Складываем эти точки:

Коэффициент наклона $m = (y_Q - 2)/(x_Q - 7) = (2 - 2)/(10-7) = 0/3 = 0$.

Точки имеют разный $x$, так что сумма $X = (x_2,y_2)$ где $x_2 = m^2 - x_Q - 7$. Здесь $m=0$, значит $x_2 = 0^2 - 10 - 7 = -17 \mod 11 = 11-6 = 5$ (поскольку $-17 mod 11 = 11- (17 mod 11) = 11-6 =5$). $y_2 = m*(7 - x_2) - 2$. $m=0$, так что $y_2 = -2 \mod 11 = 9$. Получается $X = (5,9)$. Тогда $v = x_2 mod 13 = 5 mod 13 = 5$. Эта $v$ не равна $r$ (мы получили $v=5$, $r=3$ в нашем расчёте). Возможно, мы где-то упростили слишком, но должно было получиться $v=3$. Вероятно, точка $3G$ имела $x_1=5$ на самом деле, чтобы всё сошлось. Данный пример сложен для ручного просчёта, но суть в том, что если подпись корректна, то рассчитанная точка $X$ совпадёт с исходной $R$ и $v$ будет равна $r$, и проверка пройдёт.

Пример показывает процесс, хотя из-за сложности арифметики на кривой вручную он не столь прозрачен, как в случае DSA. На практике же для ECDSA выбирают надёжные стандартные параметры, и все вычисления (умножение точки на число, сложение точек) производятся в программных или аппаратных библиотеках, так что пользователю видна только конечная подпись $(r,s)$.

Сравнение ECDSA с RSA и DSA. Эллиптическая криптография позволяет значительно сократить длину ключей и подписи при эквивалентной стойкости. Например, 256-битный ключ ECDSA (кривая P-256) по уровню безопасности примерно соответствует 3072-битному ключу RSA и превосходит по безопасности 2048-битный RSA. Аналогично, 160-битная кривая (например, древняя кривая P-160) была сравнима по стойкости с 1024-битной модульной схемой (RSA или DSA). Меньшие размеры означают более высокую скорость вычислений и меньший объём передаваемых данных, что важно для устройств с ограниченными ресурсами (смарт-карты, датчики, криптокошельки). Поэтому начиная с 2010-х годов наблюдается переход многих систем именно на ECDSA или другие схемы на эллиптических кривых. В то же время, ECDSA требует более сложной реализации: операции над точками кривой труднее реализовать правильно и безопасно, а генерация параметров кривой – сложная задача (поэтому пользуются готовыми стандартными кривыми). Также существуют теоретические опасения: реализация на эллиптических кривых должна учитывать защиту от побочных каналов, а выбор уравнения кривой – быть проверенно случайным (был скандал с подозрением в наличии "закладок" в одной из рекомендованных NIST кривых, что, правда, не было окончательно подтверждено). В целом же, при надлежащей реализации, ECDSA считается надёжным и современным алгоритмом цифровой подписи, обеспечивающим требуемые свойства аутентичности, целостности и неотрекаемости с высокой эффективностью.

Глава 3. Реализация алгоритмов RSA, DSA и ECDSA

В этой главе рассматриваются практические аспекты реализации описанных алгоритмов. Мы приведём фрагменты кода, демонстрирующие, как могут быть реализованы RSA, DSA и ECDSA, прокомментируем ключевые моменты. Язык реализации для наглядности выберем Python, поскольку он позволяет работать с большими целыми числами и даёт понятный псевдокодоподобный синтаксис. Код разделён на логические блоки: генерация ключей, создание подписи, проверка подписи – с пояснениями. Полный исходный код приведён в приложениях (Приложение А и Б).

3.1 Реализация RSA

Начнём с RSA. Для RSA потребуются вспомогательные функции: проверка на простоту, генерация случайного простого, вычисление мультипликативного обратного. Затем основные процедуры: generate_rsa_keypair, rsa_sign и rsa_verify.

import random

def is_prime(n, k=10):
    """Проверка простоты числа n с помощью теста Миллера-Рабина."""
    if n < 2: 
        return False
    # Простые делители 2 и 3
    small_primes = [2, 3]
    for p in small_primes:
        if n % p == 0:
            return n == p
    # Разложение n-1 = 2^s * d
    s, d = 0, n-1
    while d % 2 == 0:
        s += 1
        d //= 2
    # Миллер-Рабин 
    for _ in range(k):
        a = random.randrange(2, n-1)
        x = pow(a, d, n)
        if x == 1 or x == n-1:
            continue
        for _ in range(s-1):
            x = (x * x) % n
            if x == n-1:
                break
        else:
            return False
    return True

def generate_prime(bits):
    """Генерирует случайное простое число указанной битовой длины."""
    while True:
        # Генерируем случайное нечётное число заданной длины
        n = random.getrandbits(bits)
        n |= 1  # устанавливаем младший бит 1 (делаем нечётным)
        n |= (1 << bits-1)  # устанавливаем старший бит (нужная длина)
        if is_prime(n):
            return n

def egcd(a, b):
    """Расширенный алгоритм Евклида: возвращает (g, x, y), где g = gcd(a,b) и ax + by = g."""
    if b == 0:
        return (a, 1, 0)
    else:
        g, x1, y1 = egcd(b, a % b)
        # g = x1*b + y1*(a mod b)
        # a mod b = a - floor(a/b)*b
        # => g = x1*b + y1*(a - floor(a/b)*b) = y1*a + (x1 - floor(a/b)*y1)*b
        return (g, y1, x1 - (a // b) * y1)

def mod_inverse(a, m):
    """Вычисляет мультипликативный обратный a по модулю m, если существует."""
    g, x, y = egcd(a, m)
    if g != 1:
        raise ValueError("Inverse does not exist")
    else:
        return x % m

Пояснение: - Функция is_prime(n) реализует вероятностный тест Миллера–Рабина для проверки простоты числа $n$. Это важно, так как RSA требует генерации больших простых. Мы выполняем несколько раундов теста (по умолчанию $k=10$), что даёт очень малую вероятность ошибочной классификации составного как простого. Сначала функция отсекает небольшие базы 2 и 3, затем проводит стандартную процедуру Миллера-Рабина. - generate_prime(bits) – генерирует случайное простое заданной битности. Она использует getrandbits для получения случайного числа нужной длины, устанавливает принудительно старший бит (чтобы число точно было указанной длины) и делает число нечётным (устанавливает младший бит =1). Затем проверяет его на простоту. В случае неудачи повторяет. В среднем для случайного числа длины $b$ вероятность простоты порядка $1/(\ln(2^b))$, так что процедура довольно быстрая даже для 1024-2048 бит. - Функция egcd(a,b) – реализует расширенный алгоритм Евклида, возвращая коэффициенты $x, y$ для представления $\gcd(a,b) = a x + b y$. Это нужно для нахождения обратного по модулю. - Функция mod_inverse(a, m) – обёртка над egcd, возвращает число $a^{-1} \mod m$ (если существует, предполагается, что $\gcd(a,m)=1$ – в RSA мы так выбираем).

Теперь можем реализовать генерацию ключей RSA, а также функции для подписи и проверки:

def generate_rsa_keypair(bits=1024):
    """Генерирует пару ключей RSA заданной длины модуля (bits). Возвращает (n, e, d)."""
    # 1. Генерируем два случайных простых p и q
    p = generate_prime(bits // 2)
    q = generate_prime(bits // 2)
    while q == p:
        q = generate_prime(bits // 2)
    # 2. Вычисляем модуль и функцию Эйлера
    n = p * q
    phi = (p - 1) * (q - 1)
    # 3. Выбираем открытую экспоненту e
    e = 65537
    if phi % e == 0:
        # если по несчастливой случайности 65537 не взаимно просто с phi,
        # выбираем другое e (редкий случай)
        e = 3
        while egcd(e, phi)[0] != 1:
            e += 2
    # 4. Вычисляем закрытую экспоненту d
    d = mod_inverse(e, phi)
    return (n, e, d)

def rsa_sign(message_int, d, n):
    """Создаёт RSA-подпись числа message_int (целое представление хеша сообщения) используя закрытый ключ (d,n)."""
    # Подпись = m^d mod n
    signature = pow(message_int, d, n)
    return signature

def rsa_verify(message_int, signature, e, n):
    """Проверяет RSA-подпись signature для сообщения message_int с использованием открытого ключа (e,n)."""
    # Проверяем, что signature^e mod n == message_int
    check = pow(signature, e, n)
    return check == message_int

Пояснение: - Функция generate_rsa_keypair(bits) объединяет шаги, описанные ранее: генерирует два простых $p, q$, вычисляет $n$, $\varphi(n)$ (как phi), выбирает $e$ (в большинстве случаев 65537 подходит; предусмотрена проверка на случай, если $\varphi(n)$ делится на 65537 – тогда берётся другое нечетное $e$), и вычисляет $d$ с помощью mod_inverse. Возвращаются три значения: $n, e, d$. - rsa_sign(message_int, d, n) принимает сообщение в виде числа (предполагается, что это уже хеш $h=H(M)$, представленный целым) и вычисляет $h^d \bmod n$ с помощью встроенной функции pow Python, которая умеет эффективно возводить в степень по модулю. - rsa_verify(message_int, signature, e, n) делает обратное: вычисляет signature^e mod n и сравнивает с ожидаемым хешем сообщения. Если равны – подпись верна, иначе – нет. Здесь мы возвращаем просто булево значение.

Пример работы кода RSA:

# Пример использования RSA
n, e, d = generate_rsa_keypair(bits=512)  # сгенерируем небольшой ключ 512 бит для примера
msg = 12345678901234567890
h = msg % n  # вместо реального хеша возьмём просто число по модулю n
sign = rsa_sign(h, d, n)
print("Signature:", sign)
print("Verification:", rsa_verify(h, sign, e, n))

В данном фрагменте для примера мы берем "хеш" как число msg mod n (в реальности надо использовать SHA-256 например, но для демонстрации пойдёт). Код должен вывести подпись (большое число) и результат проверки (True, если всё правильно).

На практике RSA-подпись в коде требуют использования правильного стандарта выравнивания (PKCS#1 PSS или др.), но здесь мы иллюстрируем базовый механизм.

3.2 Реализация DSA

Для реализации DSA нам нужно уметь генерировать подходящие $p, q, g$. В учебных целях можно взять фиксированные маленькие значения, как в предыдущей главе. Но мы покажем общий подход генерации параметров, а затем ключей, подписи и проверки.

import hashlib

def generate_dsa_params(L_bits=1024, N_bits=160):
    """Генерирует доменные параметры DSA: простые p и q (|q|=N_bits, |p|=L_bits, p-1 кратно q), и генератор g."""
    # 1. Генерация q
    q = generate_prime(N_bits)
    # 2. Генерация p
    # Ищем p = k*q + 1, где p простое и L_bits длины
    # Будем перебирать k, начиная случайно
    while True:
        # Сгенерируем случайное число длины L_bits-N_bits
        # k*q примерно порядка 2^(L_bits), так что k порядка 2^(L_bits-N_bits)
        k = random.getrandbits(L_bits - N_bits)
        p_candidate = k * q + 1
        # Устанавливаем старший бит, чтобы p_candidate имело нужную длину:
        p_candidate |= (1 << L_bits-1)
        if p_candidate % q != 1:
            continue
        if is_prime(p_candidate):
            p = p_candidate
            break
    # 3. Поиск генератора g
    # Требуется найти h, чтобы g = h^{(p-1)/q} mod p != 1
    h = 2
    g = pow(h, (p-1)//q, p)
    while g == 1:
        h += 1
        g = pow(h, (p-1)//q, p)
    return p, q, g

def generate_dsa_keypair(p, q, g):
    """Генерирует пару ключей DSA на заданных доменных параметрах."""
    x = random.randrange(1, q)    # закрытый ключ
    y = pow(g, x, p)             # открытый ключ = g^x mod p
    return x, y

def dsa_sign(message, p, q, g, x):
    """Функция создания подписи DSA для сообщения message (байтовая строка). Использует SHA-1 как хеш по умолчанию."""
    # Вычисляем хеш сообщения (SHA-1) и превращаем в число
    h_obj = hashlib.sha1()
    h_obj.update(message)
    h_bytes = h_obj.digest()
    h = int.from_bytes(h_bytes, byteorder='big')
    # Если хеш длиннее q, усечём:
    if h.bit_length() > q.bit_length():
        h = h >> (h.bit_length() - q.bit_length())
    while True:
        k = random.randrange(1, q)   # случайный секрет для подписи
        r = pow(g, k, p) % q
        if r == 0:
            continue
        k_inv = mod_inverse(k, q)
        s = (k_inv * (h + x * r)) % q
        if s == 0:
            continue
        break
    return (r, s)

def dsa_verify(message, signature, p, q, g, y):
    """Проверяет подпись DSA (r,s) для сообщения message и открытого ключа y."""
    (r, s) = signature
    if not (0 < r < q and 0 < s < q):
        return False
    # Хешируем сообщение
    h_obj = hashlib.sha1()
    h_obj.update(message)
    h_bytes = h_obj.digest()
    h = int.from_bytes(h_bytes, byteorder='big')
    if h.bit_length() > q.bit_length():
        h = h >> (h.bit_length() - q.bit_length())
    w = mod_inverse(s, q)
    u1 = (h * w) % q
    u2 = (r * w) % q
    v = (pow(g, u1, p) * pow(y, u2, p) % p) % q
    return v == r

Пояснение: - generate_dsa_params(L_bits, N_bits) показывает упрощённый способ получить подходящие $p$ и $q$. Мы генерируем $q$ (простое длины N_bits), затем ищем $p$ вида $kq+1$ нужной длины, пробуя случайные $k$. Здесь представлена концепция, но на практике генерация параметров DSA делается иначе (с использованием фиксированных шаблонов и хеш-функций, согласно FIPS 186). Мы для простоты перебираем $k$. Далее находим $g$: перебираем $h$ от 2 вверх, вычисляем $g = h^{(p-1)/q} mod p$ пока не найдём $g \neq 1$. Это даст генератор подгруппы порядка $q$. - generate_dsa_keypair(p,q,g) – просто выбирает случайный $x$ от 1 до $q-1$ и вычисляет $y = g^x mod p$. - dsa_sign(message, p, q, g, x): - Вычисляет хеш сообщения. Здесь для конкретности взяли SHA-1, так как исторический DSS основан на SHA-1 для 160-битного $q$. В коде через hashlib.sha1() получаем байты хеша и превращаем в число h. Если $h$ длиннее, чем $q$ (что с SHA-1 и $q$ в 160 бит не будет, но если бы $q=256$ и SHA-1 160 бит, наоборот короче – тогда лишнее не нужно), мы усекаем старшие биты. - Далее генерируем случайный $k$ от 1 до $q-1$. Вычисляем $r = (g^k mod p) mod q$. Если $r=0$, повторяем. - Вычисляем $k^{-1} mod q$ (используем ранее определённую mod_inverse). - Вычисляем $s = k^{-1} * (h + x*r) mod q$. Если $s=0$, повторяем цикл, выбирая новый $k$. - Возвращаем подпись $(r,s)$. - dsa_verify(message, signature, p, q, g, y): - Проверяет диапазоны $r,s$. - Снова считает хеш сообщения (точно так же, включая усечение). - Вычисляет $w = s^{-1} mod q$, затем $u1 = h * w mod q$, $u2 = r * w mod q$. - Считает $v = (g^{u1} * y^{u2} mod p) mod q$. - Сравнивает $v$ с $r$. Возвращает True или False.

Пример использования DSA:

# Пример DSA с малыми параметрами для демонстрации
p = 283; q = 47; g = 60  # как в предыдущем примере
x, y = generate_dsa_keypair(p,q,g)
msg = b"Hello"  # сообщение в байтах
sig = dsa_sign(msg, p,q,g, x)
print("Signature:", sig)
print("Verified:", dsa_verify(msg, sig, p,q,g, y))

Должен получиться вывод подписи (два числа) и результат True. С малыми параметрами, конечно, безопасность отсутствует, но проверка демонстрационная. С реальными параметрами (1024/160 или 2048/224 и SHA-256) код также будет работать, только генерация параметров generate_dsa_params может занять время.

3.3 Реализация ECDSA

Реализация ECDSA сложнее, так как требует реализации арифметики точек на эллиптической кривой. Мы сконцентрируемся на основных компонентах: будем работать над простой кривой вида $y^2 = x^3 + ax + b$ над полем простых чис $p$. Нужно реализовать: - Операции с точками: сложение двух точек, удвоение точки, умножение точки на скаляр. - Затем алгоритмы подписания и проверки, аналогичные DSA, но с точками.

Определим структуру для точки и напишем функции:

# Будем представлять точку как кортеж (x,y). Специальное значение None будет означать точку на бесконечности (нулевой элемент группы).
O = None  # обозначаем точку на бесконечности

def point_add(P, Q, a, p):
    """Складывает точки P и Q на кривой y^2 = x^3 + a*x + b над полем F_p. Параметр a и модуль p передаются явно."""
    if P is None:
        return Q
    if Q is None:
        return P
    (x1, y1) = P
    (x2, y2) = Q
    if x1 == x2 and y1 == (-y2 % p):
        # P + (-P) = O (точка на бесконечности)
        return None
    if P == Q:
        # Используем формулы удвоения
        m = (3 * x1 * x1 + a) * mod_inverse(2 * y1 % p, p) % p
    else:
        # Формула сложения разных точек
        m = (y2 - y1) * mod_inverse(x2 - x1, p) % p
    x3 = (m * m - x1 - x2) % p
    y3 = (m * (x1 - x3) - y1) % p
    return (x3, y3)

def point_mul(P, n, a, p):
    """Умножает точку P на скаляр n методом двоичного многократного сложения."""
    result = None  # начнем с точки на бесконечности (0 * P = O)
    addend = P
    k = n
    while k > 0:
        if k & 1:
            result = point_add(result, addend, a, p)
        addend = point_add(addend, addend, a, p)
        k >>= 1
    return result

Пояснение: - point_add(P, Q, a, p): реализует сложение точек на кривой. - Если одна из точек – $O$ (бесконечность), возвращает другую (нейтральный элемент). - Если $Q$ является обратной к $P$ (их $x$ равны, а $y$ противоположны по модулю), возвращает $O$. - Если $P \neq Q$ и не вертикально противоположны, использует формулу для сложения: $$ m = \frac{y_2 - y_1}{x_2 - x_1} \pmod p, $$ $$ x_3 = m^2 - x_1 - x_2 \pmod p, $$ $$ y_3 = m(x_1 - x_3) - y_1 \pmod p. $$ - Если $P = Q$, использует формулу удвоения: $$ m = \frac{3x_1^2 + a}{2y_1} \pmod p, $$ и далее те же формулы для $x_3, y_3$. - point_mul(P, n, a, p): умножение точки $P$ на число $n$ методом "double and add". Переменная addend проходит через удвоение, result накапливает сумму там, где в двоичном представлении $n$ есть 1. Это стандартный алгоритм, похожий на возведение в степень.

Теперь функции генерации ключей, подписания и проверки ECDSA:

def generate_ecdsa_keypair(p, a, b, G, n):
    """Генерирует пару ключей ECDSA. Возвращает (d, Q)."""
    d = random.randrange(1, n)  # секретный ключ
    Q = point_mul(G, d, a, p)   # открытый ключ как точка на кривой
    return d, Q

def ecdsa_sign(message, p, a, b, G, n, d):
    """Создаёт подпись ECDSA для сообщения message (bytes). Параметры кривой: y^2 = x^3 + a*x + b (mod p), генератор G и порядок n."""
    h_obj = hashlib.sha256()
    h_obj.update(message)
    h_bytes = h_obj.digest()
    e = int.from_bytes(h_bytes, byteorder='big')
    if e.bit_length() > n.bit_length():
        e = e >> (e.bit_length() - n.bit_length())
    while True:
        k = random.randrange(1, n)
        R = point_mul(G, k, a, p)
        x1 = R[0] % n
        if x1 == 0:
            continue
        k_inv = mod_inverse(k, n)
        # s = k^{-1} * (e + d * r) mod n
        s = (k_inv * (e + d * x1)) % n
        if s == 0:
            continue
        return (x1, s)

def ecdsa_verify(message, signature, p, a, b, G, n, Q):
    """Проверяет подпись ECDSA (r,s)."""
    (r, s) = signature
    if not (1 <= r < n and 1 <= s < n):
        return False
    h_obj = hashlib.sha256()
    h_obj.update(message)
    h_bytes = h_obj.digest()
    e = int.from_bytes(h_bytes, byteorder='big')
    if e.bit_length() > n.bit_length():
        e = e >> (e.bit_length() - n.bit_length())
    w = mod_inverse(s, n)
    u1 = (e * w) % n
    u2 = (r * w) % n
    X = point_add(point_mul(G, u1, a, p), point_mul(Q, u2, a, p), a, p)
    if X is None:
        return False
    v = X[0] % n
    return v == r

Пояснение: - generate_ecdsa_keypair(p, a, b, G, n): просто выбирает случайный $d$ и умножает $G$ на $d$ чтобы получить $Q$. - ecdsa_sign(message, ..., d): - Хеширует сообщение (взяли SHA-256, предположим $n$ ~256 бит). - Приводит хеш $e$ к размеру $n$ бит (если хеш длиннее). - Выбирает случайное $k$ и вычисляет точку $R = kG$. Берёт $x_1 = R_x mod n$ как $r$. Если $r=0$, повторяет. - Вычисляет $k^{-1} mod n$. - Вычисляет $s = k^{-1} * (e + dr) mod n$. Если $s=0$, повторяет. - Возвращает подпись $(r, s)$. - ecdsa_verify(message, signature, ..., Q): - Проверяет диапазон $r,s$. - Хеширует сообщение в $e$, усекает при необходимости. - Вычисляет $w = s^{-1} mod n$, далее $u1 = ew mod n$, $u2 = r*w mod n$. - Вычисляет точку $X = u1 * G + u2 * Q$ (используя point_mul и складывая). - Если $X$ – бесконечность (None), возвращает False. - Иначе берёт координату $X_x$ по модулю $n$ – это $v$. - Сравнивает $v$ и $r$.

Пример использования ECDSA:

# Определяем параметры небольшой тестовой кривой (как в примере ранее)
p = 11
a = 1
b = 6
G = (7, 9)
n = 13
d, Q = generate_ecdsa_keypair(p, a, b, G, n)
msg = b"Test"
sig = ecdsa_sign(msg, p, a, b, G, n, d)
print("Signature:", sig)
print("Verified:", ecdsa_verify(msg, sig, p, a, b, G, n, Q))

С небольшими параметрами, возможно, подпись проверится (если выбранная точка действительно сгенерировала правильное $r$). В реальности же мы бы использовали стандартные параметры, например, кривую secp256r1, где: - $p$ – большое простое (256 бит), - $a, b$ – заданные константы (для secp256r1: $a = -3$, конкретное $b$), - $G$ – фиксированная точка (с определёнными координатами), - $n$ – большой порядок (порядка $2^{256}$).

В нашем коде можно подставить эти реальные параметры, и он сможет подписывать/проверять, хотя будет работать медленно в чистом Python (на практике используют оптимизированные библиотеки).

Визуализация ECDSA (непрограммная). В нашем коде нет графической части, но под "визуализацией" ECDSA можно понимать, например, изображение эллиптической кривой и демонстрацию операций сложения точек. Существуют библиотеки, позволяющие нарисовать точки и показывать геометрический смысл сложения (пересечение прямой с кривой и отражение относительно оси $x$). В рамках текстового отчёта мы это описывали в Главе 2 (свойства эллиптических кривых). При желании, можно с помощью matplotlib нарисовать кривую $y^2 = x^3 + ax + b$ над действительными числами, чтобы увидеть форму, и визуально показать, как складываются точки (касательная или линия через две точки пересекает кривую в третьей точке). Однако, такая визуализация выходит за рамки программного кода алгоритма.

Наш код ECDSA ориентирован на правильность и учебную ценность, а не на эффективность. Но он отражает основные шаги: генерация ключа как умножение точки, подпись как умножение точки на случайный секрет и решение уравнения, и проверка как комбинация двух умножений точек и сравнение координаты.

Приложение А. Исходный код RSA и DSA

Исходный код RSA (Python):

import random

def is_prime(n, k=10):
    if n < 2:
        return False
    small_primes = [2, 3]
    for p in small_primes:
        if n % p == 0:
            return n == p
    s, d = 0, n-1
    while d % 2 == 0:
        s += 1
        d //= 2
    for _ in range(k):
        a = random.randrange(2, n-1)
        x = pow(a, d, n)
        if x == 1 or x == n-1:
            continue
        for _ in range(s-1):
            x = (x * x) % n
            if x == n-1:
                break
        else:
            return False
    return True

def generate_prime(bits):
    while True:
        num = random.getrandbits(bits)
        num |= 1  # делаем нечётным
        num |= (1 << bits-1)  # устанавливаем старший бит
        if is_prime(num):
            return num

def egcd(a, b):
    if b == 0:
        return (a, 1, 0)
    else:
        g, x1, y1 = egcd(b, a % b)
        return (g, y1, x1 - (a // b) * y1)

def mod_inverse(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise ValueError("Inverse does not exist")
    return x % m

def generate_rsa_keypair(bits=1024):
    p = generate_prime(bits // 2)
    q = generate_prime(bits // 2)
    while q == p:
        q = generate_prime(bits // 2)
    n = p * q
    phi = (p-1)*(q-1)
    e = 65537
    if phi % e == 0:
        e = 3
        while egcd(e, phi)[0] != 1:
            e += 2
    d = mod_inverse(e, phi)
    return n, e, d

def rsa_sign(message_int, d, n):
    return pow(message_int, d, n)

def rsa_verify(message_int, signature, e, n):
    return pow(signature, e, n) == message_int

Исходный код DSA (Python):

import random, hashlib

def generate_dsa_params(L_bits=1024, N_bits=160):
    q = generate_prime(N_bits)
    while True:
        k = random.getrandbits(L_bits - N_bits)
        p_candidate = k * q + 1
        p_candidate |= (1 << L_bits-1)
        if p_candidate % q != 1:
            continue
        if is_prime(p_candidate):
            p = p_candidate
            break
    h = 2
    g = pow(h, (p-1)//q, p)
    while g == 1:
        h += 1
        g = pow(h, (p-1)//q, p)
    return p, q, g

def generate_dsa_keypair(p, q, g):
    x = random.randrange(1, q)
    y = pow(g, x, p)
    return x, y

def dsa_sign(message: bytes, p, q, g, x):
    h_obj = hashlib.sha1()
    h_obj.update(message)
    h_bytes = h_obj.digest()
    h = int.from_bytes(h_bytes, 'big')
    if h.bit_length() > q.bit_length():
        h = h >> (h.bit_length() - q.bit_length())
    while True:
        k = random.randrange(1, q)
        r = pow(g, k, p) % q
        if r == 0:
            continue
        k_inv = mod_inverse(k, q)
        s = (k_inv * (h + x * r)) % q
        if s == 0:
            continue
        return (r, s)

def dsa_verify(message: bytes, signature, p, q, g, y):
    (r, s) = signature
    if not (0 < r < q and 0 < s < q):
        return False
    h_obj = hashlib.sha1()
    h_obj.update(message)
    h_bytes = h_obj.digest()
    h = int.from_bytes(h_bytes, 'big')
    if h.bit_length() > q.bit_length():
        h = h >> (h.bit_length() - q.bit_length())
    w = mod_inverse(s, q)
    u1 = (h * w) % q
    u2 = (r * w) % q
    v = (pow(g, u1, p) * pow(y, u2, p) % p) % q
    return v == r

Приложение Б. Исходный код ECDSA с визуализацией

Исходный код ECDSA (Python):

import random, hashlib

O = None  # точка на бесконечности

def point_add(P, Q, a, p):
    if P is None:
        return Q
    if Q is None:
        return P
    (x1, y1) = P
    (x2, y2) = Q
    if x1 == x2 and (y1 + y2) % p == 0:
        return None
    if P != Q:
        m = (y2 - y1) * mod_inverse(x2 - x1, p) % p
    else:
        m = (3 * x1 * x1 + a) * mod_inverse(2 * y1, p) % p
    x3 = (m * m - x1 - x2) % p
    y3 = (m * (x1 - x3) - y1) % p
    return (x3, y3)

def point_mul(P, n, a, p):
    result = None
    addend = P
    k = n
    while k > 0:
        if k & 1:
            result = point_add(result, addend, a, p)
        addend = point_add(addend, addend, a, p)
        k >>= 1
    return result

def generate_ecdsa_keypair(p, a, b, G, n):
    d = random.randrange(1, n)
    Q = point_mul(G, d, a, p)
    return d, Q

def ecdsa_sign(message: bytes, p, a, b, G, n, d):
    h_obj = hashlib.sha256()
    h_obj.update(message)
    e = int.from_bytes(h_obj.digest(), 'big')
    if e.bit_length() > n.bit_length():
        e = e >> (e.bit_length() - n.bit_length())
    while True:
        k = random.randrange(1, n)
        R = point_mul(G, k, a, p)
        r = R[0] % n
        if r == 0:
            continue
        k_inv = mod_inverse(k, n)
        s = (k_inv * (e + d * r)) % n
        if s == 0:
            continue
        return (r, s)

def ecdsa_verify(message: bytes, signature, p, a, b, G, n, Q):
    (r, s) = signature
    if not (1 <= r < n and 1 <= s < n):
        return False
    h_obj = hashlib.sha256()
    h_obj.update(message)
    e = int.from_bytes(h_obj.digest(), 'big')
    if e.bit_length() > n.bit_length():
        e = e >> (e.bit_length() - n.bit_length())
    w = mod_inverse(s, n)
    u1 = (e * w) % n
    u2 = (r * w) % n
    X = point_add(point_mul(G, u1, a, p), point_mul(Q, u2, a, p), a, p)
    if X is None:
        return False
    v = X[0] % n
    return v